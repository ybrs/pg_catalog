import time
import subprocess
import psycopg
import pytest

CONN_STR = "host=127.0.0.1 port=5444 dbname=pgtry user=dbuser password=pencil sslmode=disable"


@pytest.fixture(scope="module")
def server():
    proc = subprocess.Popen([
        "cargo",
        "run",
        "--quiet",
        "--",
        "pg_catalog_data/pg_schema",
        "--default-catalog",
        "pgtry",
        "--default-schema",
        "public",
        "--host",
        "127.0.0.1",
        "--port",
        "5444",
    ], text=True)

    for _ in range(12):
        try:
            with psycopg.connect(CONN_STR):
                break
        except Exception:
            time.sleep(5)
    else:
        proc.terminate()
        raise RuntimeError("server failed to start")

    yield proc
    proc.terminate()
    try:
        proc.wait(timeout=5)
    except subprocess.TimeoutExpired:
        proc.kill()

QUERIES = [
    """select A.oid as access_method_id,\n       A.xmin as state_number,\n       A.amname as access_method_name\n       ,\n       A.amhandler::oid as handler_id,\n       pg_catalog.quote_ident(N.nspname) || '.' || pg_catalog.quote_ident(P.proname) as handler_name,\n       A.amtype as access_method_type\n       \nfrom pg_am A\n  join pg_proc P on A.amhandler::oid = P.oid\n  join pg_namespace N on P.pronamespace = N.oid\n  \n--  where pg_catalog.age(A.xmin) <= #TXAGE""",
    """select E.oid        as id,\n       E.xmin       as state_number,\n       extname      as name,\n       extversion   as version,\n       extnamespace as schema_id,\n       nspname      as schema_name\n       ,\n       array(select unnest\n             from unnest(available_versions)\n             where unnest > extversion) as available_updates\n       \nfrom pg_catalog.pg_extension E\n       join pg_namespace N on E.extnamespace = N.oid\n       left join (select name, array_agg(version) as available_versions\n                  from pg_available_extension_versions()\n                  group by name) V on E.extname = V.name\n       \n--  where pg_catalog.age(E.xmin) <= #TXAGE""",
    """select C.oid,\n       C.xmin as state_number,\n       C.castsource as castsource_id,\n       pg_catalog.quote_ident(SN.nspname) || '.' || pg_catalog.quote_ident(S.typname) as castsource_name,\n       C.casttarget as casttarget_id,\n       pg_catalog.quote_ident(TN.nspname) || '.' || pg_catalog.quote_ident(T.typname) as casttarget_name,\n       C.castfunc as castfunc_id,\n       pg_catalog.quote_ident(FN.nspname) || '.' || pg_catalog.quote_ident(F.proname) as castfunc_name,\n       C.castcontext,\n       C.castmethod\nfrom pg_cast C\n     left outer join pg_proc F on C.castfunc::oid = F.oid\n     left outer join pg_namespace FN on F.pronamespace = FN.oid\n     join pg_type S on C.castsource::oid = S.oid\n     join pg_namespace SN on S.typnamespace = SN.oid\n     join pg_type T on C.casttarget::oid = T.oid\n     join pg_namespace TN on T.typnamespace = TN.oid\n--  where pg_catalog.age(C.xmin) <= #TXAGE""",
    """select cls.xmin as sequence_state_number,\n       sq.seqrelid as sequence_id,\n       cls.relname as sequence_name,\n       pg_catalog.format_type(sq.seqtypid, null) as data_type,\n       sq.seqstart as start_value,\n       sq.seqincrement as inc_value,\n       sq.seqmin as min_value,\n       sq.seqmax as max_value,\n       sq.seqcache as cache_size,\n       sq.seqcycle as cycle_option,\n       pg_catalog.pg_get_userbyid(cls.relowner) as \"owner\"\nfrom pg_catalog.pg_sequence sq\n    join pg_class cls on sq.seqrelid = cls.oid\n    where cls.relnamespace = $1::oid\n        --  and pg_catalog.age(cls.xmin) <= #TXAGE""",
    """select T.oid as type_id,\n       T.xmin as type_state_number,\n       T.typname as type_name,\n       T.typtype as type_sub_kind,\n       T.typcategory as type_category,\n       T.typrelid as class_id,\n       T.typbasetype as base_type_id,\n       case when T.typtype in ('c','e') then null\n            else pg_catalog.format_type(T.typbasetype, T.typtypmod) end as type_def,\n       T.typndims as dimensions_number,\n       T.typdefault as default_expression,\n       T.typnotnull as mandatory,\n       pg_catalog.pg_get_userbyid(T.typowner) as \"owner\"\nfrom pg_catalog.pg_type T\n         left outer join pg_catalog.pg_class C\n             on T.typrelid = C.oid\nwhere T.typnamespace = $1::oid\n  --  and pg_catalog.age(T.xmin) <= #TXAGE\n  and (T.typtype in ('d','e') or\n       C.relkind = 'c'::\"char\" or\n       (T.typtype = 'b' and (T.typelem = 0 OR T.typcategory <> 'A')) or\n       T.typtype = 'p' and not T.typisdefined)\norder by 1""",
    """select T.relkind as table_kind,\n       T.relname as table_name,\n       T.oid as table_id,\n       T.xmin as table_state_number,\n       false /* T.relhasoids */ as table_with_oids,\n       T.reltablespace as tablespace_id,\n       T.reloptions as options,\n       T.relpersistence as persistence,\n       (select pg_catalog.array_agg(inhparent::bigint order by inhseqno)::varchar from pg_catalog.pg_inherits where T.oid = inhrelid) as ancestors,\n       (select pg_catalog.array_agg(inhrelid::bigint order by inhrelid)::varchar from pg_catalog.pg_inherits where T.oid = inhparent) as successors,\n       T.relispartition /* false */ as is_partition,\n       pg_catalog.pg_get_partkeydef(T.oid) /* null */ as partition_key,\n       pg_catalog.pg_get_expr(T.relpartbound, T.oid) /* null */ as partition_expression,\n       T.relam am_id,\n       pg_catalog.pg_get_userbyid(T.relowner) as \"owner\"\nfrom pg_catalog.pg_class T\nwhere relnamespace = $1::oid\n  and relkind in ('r', 'm', 'v', 'f', 'p')\n  --  and pg_catalog.age(T.xmin) <= #TXAGE\norder by table_kind, table_id""",
    """select ft.ftrelid as table_id,\n       srv.srvname as table_server,\n       ft.ftoptions as table_options,\n       pg_catalog.pg_get_userbyid(cls.relowner) as \"owner\"\nfrom pg_catalog.pg_foreign_table ft\n     left outer join pg_catalog.pg_foreign_server srv on ft.ftserver = srv.oid\n     join pg_catalog.pg_class cls on ft.ftrelid = cls.oid\nwhere cls.relnamespace = $1::oid\n  --  and pg_catalog.age(ft.xmin) <= #TXAGE\norder by table_id""",
    """with schema_procs as (select prorettype, proargtypes, proallargtypes\n                      from pg_catalog.pg_proc\n                      where pronamespace = $1::oid\n                        /* and pg_catalog.age(xmin) <= #TXAGE */ ),\n     schema_opers as (select oprleft, oprright, oprresult\n                      from pg_catalog.pg_operator\n                      where oprnamespace = $2::oid\n                        /* and pg_catalog.age(xmin) <= #TXAGE */ ),\n     schema_aggregates as (select A.aggtranstype , A.aggmtranstype \n                           from pg_catalog.pg_aggregate A\n                           join pg_catalog.pg_proc P\n                             on A.aggfnoid = P.oid\n                           where P.pronamespace = $3::oid\n                           /* and (pg_catalog.age(A.xmin) <= #TXAGE or pg_catalog.age(P.xmin) <= #TXAGE) */),\n     schema_arg_types as ( select prorettype as type_id\n                           from schema_procs\n                           union\n                           select distinct unnest(proargtypes) as type_id\n                           from schema_procs\n                           union\n                           select distinct unnest(proallargtypes) as type_id\n                           from schema_procs\n                           union\n                           select oprleft as type_id\n                           from schema_opers\n                           where oprleft is not null\n                           union\n                           select oprright as type_id\n                           from schema_opers\n                           where oprright is not null\n                           union\n                           select oprresult as type_id\n                           from schema_opers\n                           where oprresult is not null\n                           union\n                           select aggtranstype::oid as type_id\n                           from schema_aggregates\n                           union\n                           select aggmtranstype::oid as type_id\n                           from schema_aggregates\n                           \n                           )\nselect type_id, pg_catalog.format_type(type_id, null) as type_spec\nfrom schema_arg_types\nwhere type_id <> 0""",
    """with languages as (select oid as lang_oid, lanname as lang\n                   from pg_catalog.pg_language),\n     routines as (select proname as r_name,\n                         prolang as lang_oid,\n                         oid as r_id,\n                         xmin as r_state_number,\n                         proargnames as arg_names,\n                         proargmodes as arg_modes,\n                         proargtypes::int[] as in_arg_types,\n                         proallargtypes::int[] as all_arg_types,\n                         pg_catalog.pg_get_expr(proargdefaults, 0) as arg_defaults,\n                         provariadic as arg_variadic_id,\n                         prorettype as ret_type_id,\n                         proretset as ret_set,\n                         prokind /* case when proiswindow then 'w'\n                                                when proisagg then 'a'\n                                                else 'f'\n                                           end */ as kind,\n                         provolatile as volatile_kind,\n                         proisstrict as is_strict,\n                         prosecdef as is_security_definer,\n                         proconfig as configuration_parameters,\n                         procost as cost,\n                         pg_catalog.pg_get_userbyid(proowner) as \"owner\",\n                         prorows as rows ,\n                         proleakproof as is_leakproof  ,\n                         proparallel as concurrency_kind \n                  from pg_catalog.pg_proc\n                  where pronamespace = $1::oid\n                    and not (prokind = 'a') /* proisagg */\n                    /* and pg_catalog.age(xmin) <= #TXAGE */)\nselect *\nfrom routines natural join languages""",
    """select P.oid as aggregate_id,\n       P.xmin as state_number,\n       P.proname as aggregate_name,\n       P.proargnames as arg_names,\n       P.proargmodes as arg_modes,\n       P.proargtypes::int[] as in_arg_types,\n       P.proallargtypes::int[] as all_arg_types,\n       A.aggtransfn::oid as transition_function_id,\n       A.aggtransfn::regproc::text as transition_function_name,\n       A.aggtranstype as transition_type,\n       A.aggfinalfn::oid as final_function_id,\n       case when A.aggfinalfn::oid = 0 then null else A.aggfinalfn::regproc::varchar end as final_function_name,\n       case when A.aggfinalfn::oid = 0 then 0 else P.prorettype end as final_return_type,\n       A.agginitval as initial_value,\n       A.aggsortop as sort_operator_id,\n       case when A.aggsortop = 0 then null else A.aggsortop::regoper::varchar end as sort_operator_name,\n       pg_catalog.pg_get_userbyid(P.proowner) as \"owner\"\n       ,\n       A.aggfinalextra as final_extra,\n       A.aggtransspace as state_size,\n       A.aggmtransfn::oid as moving_transition_id,\n       case when A.aggmtransfn::oid = 0 then null else A.aggmtransfn::regproc::varchar end as moving_transition_name,\n       A.aggminvtransfn::oid as inverse_transition_id,\n       case when A.aggminvtransfn::oid = 0 then null else A.aggminvtransfn::regproc::varchar end as inverse_transition_name,\n       A.aggmtranstype::oid as moving_state_type,\n       A.aggmtransspace as moving_state_size,\n       A.aggmfinalfn::oid as moving_final_id,\n       case when A.aggmfinalfn::oid = 0 then null else A.aggmfinalfn::regproc::varchar end as moving_final_name,\n       A.aggmfinalextra as moving_final_extra,\n       A.aggminitval as moving_initial_value,\n       A.aggkind as aggregate_kind,\n       A.aggnumdirectargs as direct_args\n       \n       ,\n       A.aggcombinefn::oid as combine_function_id,\n       case when A.aggcombinefn::oid = 0 then null else A.aggcombinefn::regproc::varchar end as combine_function_name,\n       A.aggserialfn::oid as serialization_function_id,\n       case when A.aggserialfn::oid = 0 then null else A.aggserialfn::regproc::varchar end as serialization_function_name,\n       A.aggdeserialfn::oid as deserialization_function_id,\n       case when A.aggdeserialfn::oid = 0 then null else A.aggdeserialfn::regproc::varchar end as deserialization_function_name,\n       P.proparallel as concurrency_kind\n       \nfrom pg_catalog.pg_aggregate A\njoin pg_catalog.pg_proc P\n  on A.aggfnoid = P.oid\nwhere P.pronamespace = $1::oid\n--  and (pg_catalog.age(A.xmin) <= #TXAGE or pg_catalog.age(P.xmin) <= #TXAGE)\norder by P.oid""",
    """select O.oid as op_id,\n       O.xmin as state_number,\n       oprname as op_name,\n       oprkind as op_kind,\n       oprleft as arg_left_type_id,\n       oprright as arg_right_type_id,\n       oprresult as arg_result_type_id,\n       oprcode::oid as main_id,\n       oprcode::varchar as main_name,\n       oprrest::oid as restrict_id,\n       oprrest::varchar as restrict_name,\n       oprjoin::oid as join_id,\n       oprjoin::varchar as join_name,\n       oprcom::oid as com_id,\n       oprcom::regoper::varchar as com_name,\n       oprnegate::oid as neg_id,\n       oprnegate::regoper::varchar as neg_name,\n       oprcanmerge as merges,\n       oprcanhash as hashes,\n       pg_catalog.pg_get_userbyid(O.oprowner) as \"owner\"\nfrom pg_catalog.pg_operator O\nwhere oprnamespace = $1::oid\n  --  and pg_catalog.age(xmin) <= #TXAGE""",
    """select oid as id,\n       xmin as state_number,\n       collname as name,\n       collcollate as lc_collate,\n       collctype as lc_ctype,\n       pg_catalog.pg_get_userbyid(collowner) as \"owner\"\nfrom pg_catalog.pg_collation\nwhere collnamespace = $1::oid\n  --  and pg_catalog.age(xmin) <= #TXAGE""",
    """select O.oid as id,\n       O.xmin as state_number,\n       opcname as name,\n       opcintype::regtype::varchar as in_type,\n       case when opckeytype = 0 then null else opckeytype::regtype::varchar end as key_type,\n       opcdefault as is_default,\n       opcfamily as family_id,\n       opfname as family,\n       opcmethod as access_method_id,\n       pg_catalog.pg_get_userbyid(O.opcowner) as \"owner\"\nfrom pg_catalog.pg_opclass O join pg_catalog.pg_opfamily F on F.oid = opcfamily\nwhere opcnamespace = $1::oid\n  --  and pg_catalog.age(O.xmin) <= #TXAGE""",
    """select O.oid as id,\n       O.xmin as state_number,\n       opfname as name,\n       opfmethod as access_method_id,\n       pg_catalog.pg_get_userbyid(O.opfowner) as \"owner\"\nfrom pg_catalog.pg_opfamily O\nwhere opfnamespace = $1::oid\n  --  and pg_catalog.age(xmin) <= #TXAGE""",
    """select O.oid as id,\n       O.amopstrategy as strategy,\n       O.amopopr as op_id,\n       O.amopopr::regoperator::varchar as op_sig,\n       O.amopsortfamily /* null */ as sort_family_id,\n       SF.opfname /* null */ as sort_family,\n       O.amopfamily as family_id,\n       C.oid as class_id\nfrom pg_catalog.pg_amop O\n    left join pg_opfamily F on O.amopfamily = F.oid\n    left join pg_opfamily SF on O.amopsortfamily = SF.oid\n    left join pg_depend D on D.classid = 'pg_amop'::regclass and O.oid = D.objid and D.objsubid = 0\n    left join pg_opclass C on D.refclassid = 'pg_opclass'::regclass and C.oid = D.refobjid and D.refobjsubid = 0\nwhere C.opcnamespace = $1::oid or C.opcnamespace is null and F.opfnamespace = $2::oid\n  --  and pg_catalog.age(O.xmin) <= #TXAGE\norder by C.oid, F.oid""",
    """select P.oid as id,\n       P.amprocnum as num,\n       P.amproc::oid as proc_id,\n       P.amproc::regprocedure::varchar as proc_sig,\n       P.amproclefttype::regtype::varchar as left_type,\n       P.amprocrighttype::regtype::varchar as right_type,\n       P.amprocfamily as family_id,\n       C.oid as class_id\nfrom pg_catalog.pg_amproc P\n    left join pg_opfamily F on P.amprocfamily = F.oid\n    left join pg_depend D on D.classid = 'pg_amproc'::regclass and P.oid = D.objid and D.objsubid = 0\n    left join pg_opclass C on D.refclassid = 'pg_opclass'::regclass and C.oid = D.refobjid and D.refobjsubid = 0\nwhere C.opcnamespace = $1::oid or C.opcnamespace is null and F.opfnamespace = $2::oid\n  --  and pg_catalog.age(P.xmin) <= #TXAGE\norder by C.oid, F.oid""",
    """select tab.oid               table_id,\n       tab.relkind           table_kind,\n       ind_stor.relname      index_name,\n       ind_head.indexrelid   index_id,\n       ind_stor.xmin         state_number,\n       ind_head.indisunique  is_unique,\n       ind_head.indisprimary is_primary,\n       pg_catalog.pg_get_expr(ind_head.indpred, ind_head.indrelid) as condition,\n       (select pg_catalog.array_agg(inhparent::bigint order by inhseqno)::varchar from pg_catalog.pg_inherits where ind_stor.oid = inhrelid) as ancestors,\n       ind_stor.reltablespace tablespace_id,\n       opcmethod as access_method_id\nfrom pg_catalog.pg_class tab\n         join pg_catalog.pg_index ind_head\n              on ind_head.indrelid = tab.oid\n         join pg_catalog.pg_class ind_stor\n              on tab.relnamespace = ind_stor.relnamespace and ind_stor.oid = ind_head.indexrelid\n         left join pg_catalog.pg_opclass on pg_opclass.oid = ANY(indclass)\nwhere tab.relnamespace = $1::oid\n        and tab.relkind in ('r', 'm', 'v', 'p')\n        and ind_stor.relkind in ('i', 'I')\n--  and pg_catalog.age(ind_stor.xmin) <= #TXAGE""",
    """select T.oid table_id,\n       relkind table_kind,\n       C.oid::bigint con_id,\n       C.xmin::varchar::bigint con_state_id,\n       conname con_name,\n       contype con_kind,\n       conkey con_columns,\n       conindid index_id,\n       confrelid ref_table_id,\n       condeferrable is_deferrable,\n       condeferred is_init_deferred,\n       confupdtype on_update,\n       confdeltype on_delete,\n      connoinherit no_inherit,\n      pg_catalog.pg_get_expr(conbin, T.oid) /* consrc */ con_expression,\n       confkey ref_columns,\n       conexclop::int[] excl_operators,\n       array(select unnest::regoper::varchar from unnest(conexclop)) excl_operators_str\nfrom pg_catalog.pg_constraint C\n         join pg_catalog.pg_class T\n              on C.conrelid = T.oid\n   where relkind in ('r', 'v', 'f', 'p')\n     and relnamespace = $1::oid\n     and contype in ('p', 'u', 'f', 'c', 'x')\n     and connamespace = $2::oid\n--  and pg_catalog.age(T.xmin) <= #TXAGE or pg_catalog.age(c.xmin) <= #TXAGE""",
    """select\n       P.oid id,\n       P.xmin as state_number,\n       polname policyname,\n       polrelid table_id,\n       polpermissive /* true */ as permissive,\n       polroles roles,\n       polcmd cmd,\n       pg_get_expr(polqual, polrelid) qual,\n       pg_get_expr(polwithcheck, polrelid) with_check\nfrom pg_catalog.pg_policy P\n       join pg_catalog.pg_class C on polrelid = C.oid\nwhere relnamespace = $1::oid\n  --  and pg_catalog.age(P.xmin) <= #TXAGE\norder by polrelid""",
    """select D.objoid id, C.relkind::char as kind, D.objsubid sub_id, D.description\nfrom pg_catalog.pg_description D\n  join pg_catalog.pg_class C on D.objoid = C.oid\nwhere C.relnamespace = $1::oid and C.relkind != 'c' and D.classoid = 'pg_catalog.pg_class'::regclass\n--  and pg_catalog.age(D.xmin) <= #TXAGE\nunion all\nselect T.oid id, 'T'::char as kind, D.objsubid sub_id, D.description\nfrom pg_catalog.pg_description D\n  join pg_catalog.pg_type T on T.oid = D.objoid or T.typrelid = D.objoid\n  left join pg_catalog.pg_class C on T.typrelid = C.oid\nwhere T.typnamespace = $2::oid and (C.relkind = 'c' or C.relkind is null)\n--  and pg_catalog.age(D.xmin) <= #TXAGE\nunion all\nselect D.objoid id, pg_catalog.translate(C.contype, 'pufc', 'kkxz')::char as kind, D.objsubid sub_id, D.description\nfrom pg_catalog.pg_description D\n  join pg_catalog.pg_constraint C on D.objoid = C.oid\nwhere C.connamespace = $3::oid and D.classoid = 'pg_catalog.pg_constraint'::regclass\n--  and pg_catalog.age(D.xmin) <= #TXAGE\nunion all\nselect D.objoid id, 't'::char as kind, D.objsubid sub_id, D.description\nfrom pg_catalog.pg_description D\n  join pg_catalog.pg_trigger T on T.oid = D.objoid\n  join pg_catalog.pg_class C on C.oid = T.tgrelid\nwhere C.relnamespace = $4::oid and D.classoid = 'pg_catalog.pg_trigger'::regclass\n--  and pg_catalog.age(D.xmin) <= #TXAGE\nunion all\nselect D.objoid id, 'R'::char as kind, D.objsubid sub_id, D.description\nfrom pg_catalog.pg_description D\n  join pg_catalog.pg_rewrite R on R.oid = D.objoid\n  join pg_catalog.pg_class C on C.oid = R.ev_class\nwhere C.relnamespace = $5::oid and D.classoid = 'pg_catalog.pg_rewrite'::regclass\n--  and pg_catalog.age(D.xmin) <= #TXAGE\nunion all\nselect D.objoid id, 'F'::char as kind, D.objsubid sub_id, D.description\nfrom pg_catalog.pg_description D\n  join pg_catalog.pg_proc P on P.oid = D.objoid\nwhere P.pronamespace = $6::oid and D.classoid = 'pg_catalog.pg_proc'::regclass\n--  and pg_catalog.age(D.xmin) <= #TXAGE\nunion all\nselect D.objoid id, 'O'::char as kind, D.objsubid sub_id, D.description\nfrom pg_catalog.pg_description D\n  join pg_catalog.pg_operator O on O.oid = D.objoid\nwhere O.oprnamespace = $7::oid and D.classoid = 'pg_catalog.pg_operator'::regclass\n--  and pg_catalog.age(D.xmin) <= #TXAGE\nunion all\nselect D.objoid id, 'f'::char as kind, D.objsubid sub_id, D.description\nfrom pg_catalog.pg_description D\n  join pg_catalog.pg_opfamily O on O.oid = D.objoid\nwhere O.opfnamespace = $8::oid and D.classoid = 'pg_catalog.pg_opfamily'::regclass\n--  and pg_catalog.age(D.xmin) <= #TXAGE\nunion all\nselect D.objoid id, 'c'::char as kind, D.objsubid sub_id, D.description\nfrom pg_catalog.pg_description D\n  join pg_catalog.pg_opclass O on O.oid = D.objoid\nwhere O.opcnamespace = $9::oid and D.classoid = 'pg_catalog.pg_opclass'::regclass\n--  and pg_catalog.age(D.xmin) <= #TXAGE\nunion all\nselect D.objoid id, 'C'::char as kind, D.objsubid sub_id, D.description\nfrom pg_catalog.pg_description D\n  join pg_catalog.pg_collation C on C.oid = D.objoid\nwhere C.collnamespace = $10::oid and D.classoid = 'pg_catalog.pg_collation'::regclass\n--  and pg_catalog.age(D.xmin) <= #TXAGE\n\nunion all\nselect D.objoid id, 'P'::char as kind, D.objsubid sub_id, D.description\nfrom pg_catalog.pg_description D\n       join pg_catalog.pg_policy P on P.oid = D.objoid\n       join pg_catalog.pg_class C on P.polrelid = C.oid\nwhere C.relnamespace = $11::oid and D.classoid = 'pg_catalog.pg_policy'::regclass\n--  and pg_catalog.age(D.xmin) <= #TXAGE\n""",
    """select T.oid as object_id,\n                 T.relacl as acl\n          from pg_catalog.pg_class T\n          where relnamespace = $1::oid \n          union all\n          select T.oid as object_id,\n                 T.proacl as acl\n          from pg_catalog.pg_proc T\n          where pronamespace = $2::oid \n          union all\n          select T.oid as object_id,\n                 T.typacl as acl\n          from pg_catalog.pg_type T\n          where typnamespace = $3::oid \n          order by object_id""",
    """select\n       T.relkind as view_kind,\n       T.oid as view_id,\n       pg_catalog.pg_get_viewdef(T.oid, true) as source_text\nfrom pg_catalog.pg_class T\n  join pg_catalog.pg_namespace N on T.relnamespace = N.oid\nwhere N.oid = $1::oid\n  and T.relkind in ('m','v')\n  --  and (pg_catalog.age(T.xmin) <= #SRCTXAGE or exists(\n  --  select A.attrelid from pg_catalog.pg_attribute A where A.attrelid = T.oid and pg_catalog.age(A.xmin) <= #SRCTXAGE))""",
]

@pytest.mark.parametrize("query", QUERIES)
@pytest.mark.skip("failing query from intellij")
def test_intellij_query(server, query):
    with psycopg.connect(CONN_STR) as conn:
        cur = conn.cursor()
        cur.execute(query)
        cur.fetchall()
